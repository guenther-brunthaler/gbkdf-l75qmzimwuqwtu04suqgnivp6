#! /bin/sh
# Implement gbkdf in text mode.
#
# It generates an endless stream of output key material as lower case hex
# digits; the consumer should just stop reading once enough key material has
# been read.
#
# The path names of two files are required as arguments: The first file
# contains the salt or arbitrary size as a series of binary bytes. The second
# file shall provide the password in a single line of text using the current
# locale's character set. Only the first line is read from the password file,
# and any newline character at the end of the input line is not considered to
# be part of the password.
#
# This script uses $TMPDIR (defaults to /tmp) to store temporary working files
# containing sensitive data. It is therefore mandatory that $TMPDIR is either
# a RAM disk or resides on a securely encrypted disk. Likewise, if the system
# has been configured to use swap space, this swap space should be encrypted
# as well in order to avoid leaking sensitive data there.

set -e
# Set defaults.
hashutil=md5sum
iterations=10
# Set to non-empty for debugging.
DEBUG=


int2bigendian() {
	printf '%u' "$1"
}


int2pad() {
	local n=$1
	while test $n != 0
	do
		printf U
		n=`expr $n - 1 || :`
	done
}


h() {
	"$hashutil" | sed 's/^\([0-9a-f]*\).*/\1/' | tr -d '\n'
}


if which hexdump > /dev/null 2>& 1
then
	xd() { hexdump -ve '/1 "%02X"' | tr A-F a-f; }
else
	xd() { od -An -tx1 | tr -dc 0-9a-f; }
fi


cleanup() {
	test -z "$DEBUG" && test -n "$T" && rm -r -- "$T"
	test -n "$OK" || echo "Failed!" >& 2
}


OK=
T=
trap cleanup 0

while getopts H:i: OPT
do
	case $OPT in
		H) hashutil=$OPTARG;;
		i) iterations=$OPTARG;;
		*) false
	esac
done
shift `expr $OPTIND - 1`

test -n "$iterations"
test $iterations -ge 1
test -n "$hashutil"
hashutil=`which "$hashutil"`
test -x "$hashutil"

test $# = 2
test -f "$1"
test -f "$2"
 
if test -n "$DEBUG"
then
	T=${0##/}.debug; test -d "$T" || mkdir "$T"
else
	T=`mktemp -d "${TMPDIR:-/tmp}/${0##/}".XXXXXXXXXX`
fi
salt=$T/salt
psw=$T/psw
data=$T/data
other=$T/other

xd < "$1" > "$salt"
head -n1 "$2" | iconv -t UTF-8 | tr -d '\n' > "$psw"
> "$data"

while :
do
	n=1
	while test $n -le $iterations
	do
		n1=`expr $n - 1 || :`
		{
			int2bigendian $n
			int2pad $n1
			cat "$data"
			int2pad $n1
			cat "$salt"
			int2pad $n1
			cat "$psw"
			int2pad $n1
			cat "$salt"
		} | h > "$other"
		t=$data; data=$other; other=$t
		n=`expr $n + 1`
	done
	cat "$data" || break
done
OK=Y
