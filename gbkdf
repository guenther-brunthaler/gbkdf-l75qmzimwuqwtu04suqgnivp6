#! /bin/sh
# Implement gbkdf in text mode.
#
# It generates an endless stream of output key material as lower case hex
# digits; the consumer should just stop reading once enough key material has
# been read.
#
# The path names of two files are required as arguments: The first file
# contains the salt of arbitrary size as a series of binary bytes. The second
# file shall provide the password in a single line of text using the current
# locale's character set. Only the first line is read from the password file,
# and any newline character at the end of the input line is not considered to
# be part of the password.
#
# This script always uses /tmp (or the directory specified with the -t option)
# to store temporary working files containing sensitive data (mlock-like
# functionality is not available in shell scripts). $TMPDIR is ignored. It is
# therefore mandatory that the temporary directory is either a RAM disk or
# resides on a securely encrypted disk. Likewise, if the system has been
# configured to use swap space, this swap space should be encrypted as well in
# order to avoid leaking sensitive data there.

set -e
# Set defaults.
hashutil=md5sum
iterations=10
# Set to non-empty for debugging.
DEBUG=


int2bigendian() {
	printf '%u' "$1"
}


int2pad() {
	local n=$1
	while test $n != 0
	do
		printf U
		n=`expr $n - 1 || :`
	done
}


h() {
	"$hashutil" | sed 's/^\([0-9a-f]*\).*/\1/' | tr -d '\n'
}


if which hexdump > /dev/null 2>& 1
then
	xd() { hexdump -ve '/1 "%02x"'; }
else
	xd() { od -An -tx1 | tr -dc 0-9a-f; }
fi


cleanup() {
	test -z "$DEBUG" && test -n "$T" && rm -r -- "$T"
	test -n "$OK" || echo "Failed!" >& 2
}


OK=
T=
trap cleanup 0

unset TMPDIR
bypass_normalization=
while getopts H:i:t:N OPT
do
	case $OPT in
		H) hashutil=$OPTARG;;
		i) iterations=$OPTARG;;
		t) test -d "$OPTARG"; TMPDIR=$OPTARG;;
		N) bypass_normalization=Y;;
		*) false
	esac
done
shift `expr $OPTIND - 1`

test -n "$iterations"
test $iterations -ge 1
test -n "$hashutil"
hashutil=`which "$hashutil"`

test $# = 2
test -f "$1"
test -f "$2"
 
if test -n "$DEBUG"
then
	T=${0##/}.debug; test -d "$T" || mkdir "$T"
else
	T=`mktemp -d "${TMPDIR:-/tmp}/${0##*/}".XXXXXXXXXX`
fi
salt=$T/salt
psw=$T/psw
data=$T/data
other=$T/other

xd < "$1" > "$salt"
if test -n "$bypass_normalization"
then
	# idn and libidn are not required if -N has been specified, but then
	# no attempt will be made to normalize the password representation,
	# making the password system- and locale-dependent. (This problem can
	# still be avoided by restricting the password to ASCII characters.)
	head -n1 "$2" | tr -d '\n' > "$psw"
elif
	cvt=`which iconv 2> /dev/null` \
	&& head -n1 "$2" | "$cvt" -t US-ASCII > "$psw" 2> /dev/null
then
	# Password has already been converted. It only consists of US-ASCII
	# characters and therefore the bloated UNICODE conversion tools are
	# not required for normalization.
	:
elif cvt=`which idn 2> /dev/null`
then
	# Not using -N is preferred but requires about 250k of additional
	# installation requirements for idn binary and libidn shared library.
	unset CHARSET; head -n1 "$2" | "$cvt" -n | tr -d '\n' > "$psw"
else
	# The even more bloated uconv can also be used instead of idn.
	cvt=`which uconv`
	head -n1 "$2" | "$cvt" -x '::nfkc;' -t UTF-8 | tr -d '\n' > "$psw"
fi
> "$data"

while :
do
	n=1
	while test $n -le $iterations
	do
		n1=`expr $n - 1 || :`
		{
			int2bigendian $n
			int2pad $n1
			cat "$data"
			int2pad $n1
			cat "$salt"
			int2pad $n1
			cat "$psw"
			int2pad $n1
			cat "$salt"
		} | h > "$other"
		t=$data; data=$other; other=$t
		n=`expr $n + 1`
	done
	cat "$data" || break
done
OK=Y
