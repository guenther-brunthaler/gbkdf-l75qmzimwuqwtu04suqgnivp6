#! /bin/sh
# Implement gbkdf in text mode.
#
# It generates an endless stream of output key material as lower case hex
# digits; the consumer should just stop reading once enough key material has
# been read.
#
# The path names of two files are required as arguments: The first file
# contains the salt or arbitrary size as a series of binary bytes. The second
# file shall provide the password in a single line of text using the current
# locale's character set. Only the first line is read from the password file,
# and any newline character at the end of the input line is not considered to
# be part of the password.
#
# This script always uses /tmp (or the directory specified with the -t option)
# to store temporary working files containing sensitive data (mlock-like
# functionality is not available in shell scripts). $TMPDIR is ignored. It is
# therefore mandatory that the temporary directory is either a RAM disk or
# resides on a securely encrypted disk. Likewise, if the system has been
# configured to use swap space, this swap space should be encrypted as well in
# order to avoid leaking sensitive data there.

set -e
# Set defaults.
hashutil=md5sum
iterations=10
# Set to non-empty for debugging.
DEBUG=


int2bigendian() {
	printf '%u' "$1"
}


int2pad() {
	local n=$1
	while test $n != 0
	do
		printf U
		n=`expr $n - 1 || :`
	done
}


h() {
	"$hashutil" | sed 's/^\([0-9a-f]*\).*/\1/' | tr -d '\n'
}


if which hexdump > /dev/null 2>& 1
then
	xd() { hexdump -ve '/1 "%02x"'; }
else
	xd() { od -An -tx1 | tr -dc 0-9a-f; }
fi


cleanup() {
	test -z "$DEBUG" && test -n "$T" && rm -r -- "$T"
	test -n "$OK" || echo "Failed!" >& 2
}


OK=
T=
trap cleanup 0

use_password_as_is=
unrestricted_unicode_range_for_normalization=
unset TMPDIR
while getopts H:i:t:up OPT
do
	case $OPT in
		H) hashutil=$OPTARG;;
		i) iterations=$OPTARG;;
		t) test -d "$OPTARG"; TMPDIR=$OPTARG;;
		p) use_password_as_is=Y;;
		u) unrestricted_unicode_range_for_normalization=Y;;
		*) false
	esac
done
shift `expr $OPTIND - 1`

test -n "$iterations"
test $iterations -ge 1
test -n "$hashutil"
hashutil=`which "$hashutil"`
test -x "$hashutil"

test $# = 2
test -f "$1"
test -f "$2"
 
if test -n "$DEBUG"
then
	T=${0##/}.debug; test -d "$T" || mkdir "$T"
else
	T=`mktemp -d "${TMPDIR:-/tmp}/${0##/}".XXXXXXXXXX`
fi
salt=$T/salt
psw=$T/psw
data=$T/data
other=$T/other

xd < "$1" > "$salt"
if test -z "$use_password_as_is"
then
	if test -z "$unrestricted_unicode_range_for_normalization"
	then
		# If neither -p nor -u have been specified, the password is
		# first converted to WINDOWS-1252 and then to UTF-8. The first
		# conversion guarantees that no UTF-16 substutition blocks or
		# decomposed UNICODE characters will be present.
		head -n1 "$2" | tr -d '\n' \
			| iconv -t WINDOWS-1252 \
			| iconv -f WINDOWS-1252 -t UTF-8 > "$psw"
	else
		# If -u (bot not -p) has been specified, the password is
		# directly converted to UTF-8. This allows arbitrary
		# characters to be used in the input, but the script can no
		# longer normalize decomposed characters into composed ones as
		# dictated by the specification. It is therefore up to the
		# user to not provide decomposed characters on input.
		head -n1 "$2" | tr -d '\n' \
			| iconv -t WINDOWS-1252 \
			| iconv -f WINDOWS-1252 -t UTF-8 > "$psw"
	fi
else
	# iconv is not required at all if -p has been specified, but then no
	# attempt is made to convert the password's representation into
	# normalized UTF-8. In this case the user is expected to provide a
	# password which has already been properly normalized to UTF-8
	# according to the specification. This will always be the case if the
	# password consists of ASCII characters only.
	head -n1 "$2" | tr -d '\n' > "$psw"
fi
> "$data"

while :
do
	n=1
	while test $n -le $iterations
	do
		n1=`expr $n - 1 || :`
		{
			int2bigendian $n
			int2pad $n1
			cat "$data"
			int2pad $n1
			cat "$salt"
			int2pad $n1
			cat "$psw"
			int2pad $n1
			cat "$salt"
		} | h > "$other"
		t=$data; data=$other; other=$t
		n=`expr $n + 1`
	done
	cat "$data" || break
done
OK=Y
